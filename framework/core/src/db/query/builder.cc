#include "pf/basic/string.h"
#include "pf/support/helpers.h"
#include "pf/sys/assert.h"
#include "pf/db/query/grammars/grammar.h"
#include "pf/db/connection_interface.h"
#include "pf/db/query/join_clause.h"
#include "pf/db/query/builder.h"

using namespace pf_basic::string;
using namespace pf_basic::type;
using namespace pf_support;
using namespace pf_db::query;

//The builder construct function.
Builder::Builder(ConnectionInterface *connection, grammars::Grammar *grammar) {
  connection_ = connection;
  grammar_ = is_null(grammar) ? connection->get_query_grammar() : grammar;
}

//The builder destruct function.
Builder::~Builder() {

}

//Set the columns to be selected.
Builder &Builder::select(const std::vector<std::string> &columns) {
  columns_ = columns;
  return *this;
}

//Add a new "raw" select expression to the query.
Builder &Builder::select_raw(
    const std::string &expression, db_query_bindings_t &bindings) {
  add_select({expression});
  if (!bindings.empty())
    add_binding(bindings, "select");

  return *this;
}

//Add a subselect expression to the query.
Builder &Builder::select_sub(Builder &query, const std::string &as) {
  // Here, we will parse this query into an SQL string and an array of bindings
  // so we can add it to the query builder using the selectRaw method so the 
  // query is included in the real SQL generated by this builder instance.

  std::string sql{""};
  db_query_bindings_t bindings;
  parse_subselect(query, sql, bindings);

  return select_raw("(" + sql + ") as " + grammar_->wrap(as), bindings);
}

//Add a subselect expression to the query.
Builder &Builder::select_sub(
    std::function<void(Builder *)> callback, const std::string &as) {

  //We need safe use the query object with unique_ptr.
  std::unique_ptr<Builder> query;
  Builder *_query = new_query();
  unique_move(Builder, _query, query);

  // If the given query is a Closure, we will execute it while passing in a new
  // query instance to the Closure. This will give the developer a chance to
  // format and work with the query before we cast it to a raw SQL string.
  callback(query.get());

  return select_sub(*query.get(), as);
}

//Parse the sub-select query into SQL and bindings.
void Builder::parse_subselect(
    Builder &query, std::string &sql, db_query_bindings_t &bindings) {
  query.columns_ = {query.columns_[0]};

  sql = query.to_sql();
  bindings = *query.get_bindings();
}

//Parse the sub-select query into SQL and bindings.
void Builder::parse_subselect(
    const std::string &query, std::string &sql, db_query_bindings_t &bindings) {
  sql = query;
  bindings = {};
}

//Add a new select column to the query.
Builder &Builder::add_select(const std::vector<std::string> &column) {
  for (const std::string &col : column)
    columns_.push_back(col);
  return *this;
}

//Add a join clause to the query.
Builder &Builder::join(const std::string &table, 
                       std::function<void(Builder *)> callback,
                       const std::string &, 
                       const std::string &, 
                       const std::string &type, 
                       bool) {
  JoinClause join(this, type, table);

  // If the first "column" of the join is really a Closure instance the developer
  // is trying to build a join with a complex "on" clause containing more than
  // one condition, so we'll add the join and call a Closure with the query.
  callback(&join);

  joins_.push_back(join);

  add_binding(*join.get_bindings(), "join");

  return *this;
}

//Add a join clause to the query.
Builder &Builder::join(const std::string &table, 
                       const std::string &first,
                       const std::string &oper, 
                       const std::string &second, 
                       const std::string &type, 
                       bool where) {

  // If the column is simply a string, we can assume the join simply has a basic 
  // "on" clause with a single condition. So we will just build the join with
  // this simple join clauses attached to it. There is not a join callback.

  JoinClause join(this, type, table);

  if (where) {
    join.where(first, oper, second);
  } else {
    join.on(first, oper, second);
  }
  joins_.push_back(join);

  add_binding(*join.get_bindings(), "join");

  return *this;
}

//Add a "cross join" clause to the query.
Builder &Builder::cross_join(const std::string &table, 
                             const std::string &first, 
                             const std::string &oper, 
                             const std::string &second) {
  if (first != "")
    return join(table, first, oper, second, "cross");

  JoinClause new_join(this, "cross", table);
  joins_.push_back(new_join);
 
  return *this;
}


void Builder::merge_wheres(std::vector<db_query_array_t> &wheres, 
                           variable_array_t &bindings) {
  for (db_query_array_t &where : wheres)
    wheres_.push_back(where);

  if (bindings_["where"].empty()) 
    bindings_["where"] = {};

  for (variable_t &binding : bindings)
    bindings_["where"].push_back(binding);
}

//Add a basic where clause to the query.
Builder &Builder::where(const std::string &column, 
                        const std::string &oper, 
                        const variable_t &value, 
                        const std::string &boolean) {
  // Here we will make some assumptions about the operator. If only 2 values are 
  // passed to the method, we will assume that the operator is an equals sign
  // and keep going. Otherwise, we'll require the operator to be passed in.
  bool use_default = ("" == oper) && (value == "") && ("and" == boolean);
  auto value_oper = prepare_value_and_operator(value.data, oper, use_default);

  variable_t rvalue{value_oper[0]};
  std::string roper{value_oper[1]};

  // If the given operator is not found in the list of valid operators we will
  // assume that the developer is just short-cutting the '=' operators and
  // we will set the operators to '=' and set the values appropriately.
  if (invalid_operator(roper)) {
    rvalue = roper;
    roper = "=";
  }

  // If the value is "null", we will just assume the developer wants to add a 
  // where null clause to the query. So, we will allow a short-cut here to
  // that method for convenience so the developer doesn't have to check.
  if (empty(rvalue))
    return where_null(column, boolean, roper != "=");

  // If the column is making a JSON reference we'll check to see if the value 
  // is a boolean. If it is, we'll add the raw boolean string as an actual
  // value to the query to ensure this is properly handled by the query.
  if (contains(column, {"->"}) && kVariableTypeBool == rvalue.type) {
    rvalue = rvalue == true ? "true" : "false";
    rvalue.type = static_cast<var_t>(DB_EXPRESSION_TYPE);
  }

  // Now that we are working with just a simple query we can put the elements 
  // in our array and add the query binding to our array of bindings that
  // will be bound to each SQL statements when it is finally executed. 
  std::string type{"Basic"};

  db_query_array_t where;
  where.items = { //PHP compact can collect the variable with names.
    {"type", type}, {"column", column}, {"operator", roper}, 
    {"value", rvalue}, {"boolean", boolean}
  };
  wheres_.push_back(where);

  if (rvalue.type != DB_EXPRESSION_TYPE)
    add_binding(rvalue, "where");

  return *this;
}

//Add a basic where clause to the query.
Builder &Builder::where(const std::string &column, 
                        const std::string &oper, 
                        closure_t value, 
                        const std::string &boolean) {

  // Here we will make some assumptions about the operator. If only 2 values are 
  // passed to the method, we will assume that the operator is an equals sign
  // and keep going. Otherwise, we'll require the operator to be passed in.
  bool use_default = ("" == oper) && ("and" == boolean);
  auto value_oper = prepare_value_and_operator("closure_t", oper, use_default);

  variable_t rvalue{value_oper[0]};
  std::string roper{value_oper[1]};

  // If the given operator is not found in the list of valid operators we will
  // assume that the developer is just short-cutting the '=' operators and
  // we will set the operators to '=' and set the values appropriately.
  if (invalid_operator(roper)) {
    rvalue = roper;
    roper = "=";
  }

  if (rvalue == "closure_t")
    return where_sub(column, oper, value, boolean);

  // If the value is "null", we will just assume the developer wants to add a 
  // where null clause to the query. So, we will allow a short-cut here to
  // that method for convenience so the developer doesn't have to check.
  if (empty(rvalue))
    return where_null(column, boolean, roper != "=");

  // If the column is making a JSON reference we'll check to see if the value 
  // is a boolean. If it is, we'll add the raw boolean string as an actual
  // value to the query to ensure this is properly handled by the query.
  if (contains(column, {"->"}) && kVariableTypeBool == rvalue.type) {
    rvalue = rvalue == true ? "true" : "false";
    rvalue.type = static_cast<var_t>(DB_EXPRESSION_TYPE);
  }

  // Now that we are working with just a simple query we can put the elements 
  // in our array and add the query binding to our array of bindings that
  // will be bound to each SQL statements when it is finally executed. 
  std::string type{"Basic"};

  db_query_array_t where;
  where.items = { //PHP compact can collect the variable with names.
    {"type", type}, {"column", column}, {"operator", roper}, 
    {"value", rvalue}, {"boolean", boolean}
  };
  wheres_.push_back(where);

  if (rvalue.type != DB_EXPRESSION_TYPE)
    add_binding(rvalue, "where");

  return *this;
}

//Add an array of where clauses to the query.
Builder &Builder::add_array_of_wheres(
    const std::vector<variable_array_t> &columns,
    const std::string &boolean,
    const std::string &method) {

  return where_nested([&columns, &method](Builder *query){
    for (auto values : columns) {
      #define get(n) values.size() > (n) + 1 ? values[n].data : ""
      auto _boolean = empty(values[3]) ? "and" : values[3].data;
      if ("where" == method) {
        query->where(get(0), get(1), get(2), _boolean);
      } else if ("where_column" == method) {
        query->where_column(get(0), get(1), get(2), _boolean);
      }
    }
  }, boolean);
}

//Add an array of where clauses to the query.
Builder &Builder::add_array_of_wheres(variable_set_t &columns,
                                      const std::string &boolean,
                                      const std::string &method) {

  return where_nested([this, &columns, &method](Builder *query){
    for (auto it = columns.begin(); it != columns.end(); ++it) {
      if ("where" == method) {
        query->where(it->first, "=", it->second.data);
      } else if ("where_column") {
        query->where_column(it->first, "=", it->second.data);
      }
    }
  }, boolean);
}

//Prepare the value and operator for a where clause.
variable_array_t Builder::prepare_value_and_operator(const std::string &value, 
                                                     const std::string &oper, 
                                                     bool use_default) {
  if (use_default) {
    return {oper, "="};
  } else if (invalid_operator_and_value(oper, value)) {
    AssertEx(false, "Illegal operator and value combination.");
  }
  return {value, oper};
}
