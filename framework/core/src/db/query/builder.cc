#include "pf/basic/string.h"
#include "pf/support/helpers.h"
#include "pf/sys/assert.h"
#include "pf/db/query/grammars/grammar.h"
#include "pf/db/connection_interface.h"
#include "pf/db/query/join_clause.h"
#include "pf/db/query/builder.h"

using namespace pf_basic::string;
using namespace pf_basic::type;
using namespace pf_support;
using namespace pf_db::query;

//The builder construct function.
Builder::Builder(ConnectionInterface *connection, grammars::Grammar *grammar) {
  connection_ = connection;
  grammar_ = is_null(grammar) ? connection->get_query_grammar() : grammar;
  bindings_ = {
    {"select", {}},
    {"join", {}},
    {"where", {}},
    {"having", {}},
    {"order", {}},
    {"union", {}},
  };

  operators_ = {
    "=", "<", ">", "<=", ">=", "<>", "!=", "<=>",
    "like", "like binary", "not like", "between", "ilike",
    "&", "|", "^", "<<", ">>",
    "rlike", "regexp", "not regexp",
    "~", "~*", "!~", "!~*", "similar to",
    "not similar to", "not ilike", "~~*", "!~~*",
  };
}

//The builder destruct function.
Builder::~Builder() {

}

//Set the columns to be selected.
Builder &Builder::select(const std::vector<std::string> &columns) {
  columns_ = columns;
  return *this;
}

//Add a new "raw" select expression to the query.
Builder &Builder::select_raw(
    const std::string &expression, db_query_bindings_t &bindings) {
  add_select({expression});
  if (!bindings.empty())
    add_binding(bindings, "select");

  return *this;
}

//Add a subselect expression to the query.
Builder &Builder::select_sub(Builder &query, const std::string &as) {
  // Here, we will parse this query into an SQL string and an array of bindings
  // so we can add it to the query builder using the selectRaw method so the 
  // query is included in the real SQL generated by this builder instance.

  std::string sql{""};
  db_query_bindings_t bindings;
  parse_subselect(query, sql, bindings);

  return select_raw("(" + sql + ") as " + grammar_->wrap(as), bindings);
}

//Add a subselect expression to the query.
Builder &Builder::select_sub(
    std::function<void(Builder *)> callback, const std::string &as) {

  //We need safe use the query object with unique_ptr.
  std::unique_ptr<Builder> query;
  Builder *_query = new_query();
  unique_move(Builder, _query, query);

  // If the given query is a Closure, we will execute it while passing in a new
  // query instance to the Closure. This will give the developer a chance to
  // format and work with the query before we cast it to a raw SQL string.
  callback(query.get());

  return select_sub(*query.get(), as);
}

//Parse the sub-select query into SQL and bindings.
void Builder::parse_subselect(
    Builder &query, std::string &sql, db_query_bindings_t &bindings) {
  query.columns_ = {query.columns_[0]};

  sql = query.to_sql();
  bindings = *query.get_bindings();
}

//Parse the sub-select query into SQL and bindings.
void Builder::parse_subselect(
    const std::string &query, std::string &sql, db_query_bindings_t &bindings) {
  sql = query;
  bindings = {};
}

//Add a new select column to the query.
Builder &Builder::add_select(const std::vector<std::string> &column) {
  for (const std::string &col : column)
    columns_.push_back(col);
  return *this;
}

//Add a join clause to the query.
Builder &Builder::join(const std::string &table, 
                       std::function<void(Builder *)> callback,
                       const std::string &, 
                       const std::string &, 
                       const std::string &type, 
                       bool) {
  JoinClause join(this, type, table);

  // If the first "column" of the join is really a Closure instance the developer
  // is trying to build a join with a complex "on" clause containing more than
  // one condition, so we'll add the join and call a Closure with the query.
  callback(&join);

  joins_.push_back(join);

  add_binding(*join.get_bindings(), "join");

  return *this;
}

//Add a join clause to the query.
Builder &Builder::join(const std::string &table, 
                       const std::string &first,
                       const std::string &oper, 
                       const std::string &second, 
                       const std::string &type, 
                       bool where) {

  // If the column is simply a string, we can assume the join simply has a basic 
  // "on" clause with a single condition. So we will just build the join with
  // this simple join clauses attached to it. There is not a join callback.

  JoinClause join(this, type, table);

  if (where) {
    join.where(first, oper, second);
  } else {
    join.on(first, oper, second);
  }
  joins_.push_back(join);

  add_binding(*join.get_bindings(), "join");

  return *this;
}

//Add a "cross join" clause to the query.
Builder &Builder::cross_join(const std::string &table, 
                             const std::string &first, 
                             const std::string &oper, 
                             const std::string &second) {
  if (first != "")
    return join(table, first, oper, second, "cross");

  JoinClause new_join(this, "cross", table);
  joins_.push_back(new_join);
 
  return *this;
}


void Builder::merge_wheres(std::vector<db_query_array_t> &wheres, 
                           variable_array_t &bindings) {
  for (db_query_array_t &where : wheres)
    wheres_.push_back(where);

  if (bindings_["where"].empty()) 
    bindings_["where"] = {};

  for (variable_t &binding : bindings)
    bindings_["where"].push_back(binding);
}

//Add a basic where clause to the query.
Builder &Builder::where(const std::string &column, 
                        const std::string &oper, 
                        const variable_t &value, 
                        const std::string &boolean) {
  // Here we will make some assumptions about the operator. If only 2 values are 
  // passed to the method, we will assume that the operator is an equals sign
  // and keep going. Otherwise, we'll require the operator to be passed in.
  bool use_default = (value == "") && ("and" == boolean);
  auto value_oper = prepare_value_and_operator(value.data, oper, use_default);

  variable_t rvalue{value_oper[0]};
  std::string roper{value_oper[1]};

  // If the given operator is not found in the list of valid operators we will
  // assume that the developer is just short-cutting the '=' operators and
  // we will set the operators to '=' and set the values appropriately.
  if (invalid_operator(roper)) {
    rvalue = roper;
    roper = "=";
  }

  // If the value is "null", we will just assume the developer wants to add a 
  // where null clause to the query. So, we will allow a short-cut here to
  // that method for convenience so the developer doesn't have to check.
  if (empty(rvalue))
    return where_null(column, boolean, roper != "=");

  // If the column is making a JSON reference we'll check to see if the value 
  // is a boolean. If it is, we'll add the raw boolean string as an actual
  // value to the query to ensure this is properly handled by the query.
  if (contains(column, {"->"}) && kVariableTypeBool == rvalue.type) {
    rvalue = rvalue == true ? "true" : "false";
    rvalue.type = static_cast<var_t>(DB_EXPRESSION_TYPE);
  }

  // Now that we are working with just a simple query we can put the elements 
  // in our array and add the query binding to our array of bindings that
  // will be bound to each SQL statements when it is finally executed. 
  std::string type{"Basic"};

  db_query_array_t where;
  where.items = { //PHP compact can collect the variable with names.
    {"type", type}, {"column", column}, {"operator", roper}, 
    {"value", rvalue}, {"boolean", boolean}
  };
  wheres_.push_back(where);

  if (rvalue.type != DB_EXPRESSION_TYPE)
    add_binding(rvalue, "where");

  return *this;
}

//Add a basic where clause to the query.
Builder &Builder::where(const std::string &column, 
                        const std::string &oper, 
                        closure_t value, 
                        const std::string &boolean) {

  // Here we will make some assumptions about the operator. If only 2 values are 
  // passed to the method, we will assume that the operator is an equals sign
  // and keep going. Otherwise, we'll require the operator to be passed in.
  bool use_default = ("" == oper) && ("and" == boolean);
  auto value_oper = prepare_value_and_operator("closure_t", oper, use_default);

  variable_t rvalue{value_oper[0]};
  std::string roper{value_oper[1]};

  // If the given operator is not found in the list of valid operators we will
  // assume that the developer is just short-cutting the '=' operators and
  // we will set the operators to '=' and set the values appropriately.
  if (invalid_operator(roper)) {
    rvalue = roper;
    roper = "=";
  }

  if (rvalue == "closure_t")
    return where_sub(column, oper, value, boolean);

  // If the value is "null", we will just assume the developer wants to add a 
  // where null clause to the query. So, we will allow a short-cut here to
  // that method for convenience so the developer doesn't have to check.
  if (empty(rvalue))
    return where_null(column, boolean, roper != "=");

  // If the column is making a JSON reference we'll check to see if the value 
  // is a boolean. If it is, we'll add the raw boolean string as an actual
  // value to the query to ensure this is properly handled by the query.
  if (contains(column, {"->"}) && kVariableTypeBool == rvalue.type) {
    rvalue = rvalue == true ? "true" : "false";
    rvalue.type = static_cast<var_t>(DB_EXPRESSION_TYPE);
  }

  // Now that we are working with just a simple query we can put the elements 
  // in our array and add the query binding to our array of bindings that
  // will be bound to each SQL statements when it is finally executed. 
  std::string type{"basic"};

  db_query_array_t where;
  where.items = { //PHP compact can collect the variable with names.
    {"type", type}, {"column", column}, {"operator", roper}, 
    {"value", rvalue}, {"boolean", boolean}
  };
  wheres_.push_back(where);

  if (rvalue.type != DB_EXPRESSION_TYPE)
    add_binding(rvalue, "where");

  return *this;
}

//Add an array of where clauses to the query.
Builder &Builder::add_array_of_wheres(
    const std::vector<variable_array_t> &columns,
    const std::string &boolean,
    const std::string &method) {
  #define get(n) (values.size() > (n) + 1 ? values[n].data : "")
  return where_nested([&columns, &method](Builder *query){
    for (auto values : columns) {
      auto _boolean = "" == get(3) ? "and" : get(3);
      if ("where" == method) {
        query->where(get(0), get(1), get(2), _boolean);
      } else if ("where_column" == method) {
        query->where_column(get(0), get(1), get(2), _boolean);
      }
    }
  }, boolean);
  #undef get
}

//Add an array of where clauses to the query.
Builder &Builder::add_array_of_wheres(variable_set_t &columns,
                                      const std::string &boolean,
                                      const std::string &method) {

  return where_nested([this, &columns, &method](Builder *query){
    for (auto it = columns.begin(); it != columns.end(); ++it) {
      if ("where" == method) {
        query->where(it->first, "=", it->second.data);
      } else if ("where_column") {
        query->where_column(it->first, "=", it->second.data);
      }
    }
  }, boolean);
}

//Prepare the value and operator for a where clause.
variable_array_t Builder::prepare_value_and_operator(const std::string &value, 
                                                     const std::string &oper, 
                                                     bool use_default) {
  if (use_default) {
    return {oper, "="};
  } else if (invalid_operator_and_value(oper, value)) {
    AssertEx(false, "Illegal operator and value combination.");
  }
  return {value, oper};
}

//Determine if the given operator and value combination is legal.
bool Builder::invalid_operator_and_value(const std::string &oper, 
                                         const variable_t &value) {
  return empty(value) && in_array(oper, operators_) && 
         !in_array(oper, {"=", "<>", "!="});
}

//Determine if the given operator is supported.
bool Builder::invalid_operator(const std::string &oper) {
  return !in_array(oper, operators_) && 
         !in_array(oper, grammar_->get_operators());
}

//Add a "where" clause comparing two columns to the query.
Builder &Builder::where_column(const std::string &first, 
                               const std::string &oper, 
                               const std::string &second, 
                               const std::string &boolean) {
  // If the given operator is not found in the list of valid operators we will
  // assume that the developer is just short-cutting the '=' operators and
  // we will set the operators to '=' and set the values appropriately.
  std::string rsecond{second}, roper{oper};
  if (invalid_operator(oper)) {
    rsecond = oper;
    roper = "=";
  }
  // Finally, we will add this where clause into this array of clauses that we
  // are building for the query. All of them will be compiled via a grammar 
  // once the query is about to be executed and run against the database.
  std::string type{"column"}; //see grammar where_calls_.

  db_query_array_t where;
  where.items = { //PHP compact can collect the variable with names.
    {"type", type}, {"first", first}, {"operator", roper}, 
    {"second", rsecond}, {"boolean", boolean}
  };
  wheres_.push_back(where);

  return *this;
}

//Add a raw where clause to the query.
Builder &Builder::where_raw(const std::string &sql, 
                            db_query_bindings_t &bindings, 
                            const std::string &boolean) {
  db_query_array_t where;
  where.items = { //PHP compact can collect the variable with names.
    {"type", "raw"}, {"sql", sql}, {"boolean", boolean}
  };
  wheres_.push_back(where);
 
  add_binding(bindings, "where");

  return *this;
}

//Add a "where in" clause to the query.
Builder &Builder::where_in(const std::string &column, 
                           const variable_array_t &values, 
                           const std::string &boolean, 
                           bool isnot) {
  db_query_array_t where;
  where.items = { //PHP compact can collect the variable with names.
    {"type", isnot ? "notin" : "in"}, {"column", column}, {"boolean", boolean},
  };

  size_t i{0};
  for (const variable_t &value : values)
    where.values[std::to_string(i++)] = value;
  wheres_.push_back(where);

  // Finally we'll add a binding for each values unless that value is an expression
  // in which case we will just skip over it since it will be the query as a raw 
  // string and not as a parameterized place-holder to be replaced by the ENV(PDO).
  for (const variable_t &value : values) {
    if (value.type != DB_EXPRESSION_TYPE)
      add_binding(value, "where");
  }

  return *this;
}

//Add a where in with a sub-select to the query.
Builder &Builder::where_insub(const std::string &column, 
                              closure_t callback, 
                              const std::string &boolean, 
                              bool isnot) {
  auto query = new_query();
  db_query_array_t where;
  unique_move(Builder, query, where.query);

  // To create the exists sub-select, we will actually create a query and call the 
  // provided callback with the query so the developer may set any of the query 
  // conditions they want for the in clause, then we'll put it in this array.
  callback(where.query.get());

  where.items = {
    {"type", isnot ? "not_insub" : "insub"}, {"column", column}, 
    {"boolean", boolean},
  };

  wheres_.push_back(where);

  add_binding(where.query->get_bindings(), "where");

  return *this;
}

//Add an external sub-select to the query.
Builder &Builder::where_in_existing_query(const std::string &column,
                                          Builder &query,
                                          const std::string &boolean,
                                          bool isnot) {
  db_query_array_t where;
  auto _query = query.new_query();
  unique_move(Builder, _query, where.query);

  where.items = {
    {"type", isnot ? "not_insub" : "insub"}, {"column", column}, 
    {"boolean", boolean},
  };
  wheres_.push_back(where);

  add_binding(where.query->get_bindings(), "where");

  return *this;
}

//Add a "where null" clause to the query.
Builder &Builder::where_null(const std::string &column, 
                             const std::string &boolean, 
                             bool isnot) {
  db_query_array_t where;
  where.items = {
    {"type", isnot ? "notnull" : "null"}, {"column", column}, 
    {"boolean", boolean},
  };
  wheres_.push_back(where);
  return *this;
}

//Add a where between statement to the query.
Builder &Builder::where_between(const std::string &column,
                                const variable_array_t &values,
                                const std::string &boolean,
                                bool isnot) {
  db_query_array_t where;
  where.items = {
    {"type", "between"}, {"column", column}, {"boolean", boolean}, 
    {"not", isnot},
  };

  variable_set_t _values;
  size_t i{0};
  for (const variable_t &value : values)
    _values[std::to_string(i++)] = value;

  add_binding(_values, "where");

  return *this;
}

//Add a "where date" statement to the query.
Builder &Builder::where_date(const std::string &column,
                             const std::string &oper,
                             const variable_t &value,
                             const std::string &boolean) {
  bool use_default = (value == "") && ("and" == boolean);
  auto value_oper = prepare_value_and_operator(value.data, oper, use_default);

  variable_t rvalue{value_oper[0]};
  std::string roper{value_oper[1]};
 
  return add_date_based_where("date", column, roper, rvalue, boolean);
}

//Add a "where day" statement to the query.
Builder &Builder::where_day(const std::string &column, 
                            const std::string &oper, 
                            const variable_t &value, 
                            const std::string &boolean) {
  bool use_default = (value == "") && ("and" == boolean);
  auto value_oper = prepare_value_and_operator(value.data, oper, use_default);

  variable_t rvalue{value_oper[0]};
  std::string roper{value_oper[1]};
 
  return add_date_based_where("day", column, roper, rvalue, boolean);
}

//Add a "where month" statement to the query.
Builder &Builder::where_month(const std::string &column, 
                              const std::string &oper, 
                              const variable_t &value, 
                              const std::string &boolean) {
  bool use_default = (value == "") && ("and" == boolean);
  auto value_oper = prepare_value_and_operator(value.data, oper, use_default);

  variable_t rvalue{value_oper[0]};
  std::string roper{value_oper[1]};
 
  return add_date_based_where("month", column, roper, rvalue, boolean);
}

//Add a "where year" statement to the query.
Builder &Builder::where_year(const std::string &column, 
                             const std::string &oper, 
                             const variable_t &value, 
                             const std::string &boolean) {
  bool use_default = (value == "") && ("and" == boolean);
  auto value_oper = prepare_value_and_operator(value.data, oper, use_default);

  variable_t rvalue{value_oper[0]};
  std::string roper{value_oper[1]};
 
  return add_date_based_where("year", column, roper, rvalue, boolean);
}

//Add another query builder as a nested where to the query builder.
Builder &Builder::add_nested_where_query(Builder *query,
                                         const std::string &boolean) {
  if (!query->wheres_.empty()) {
    db_query_array_t where;
    where.items = {
      {"type", "nested"}, {"boolean", boolean}
    };
    unique_move(Builder, query, where.query);
    add_binding(where.query.get(), "where");
  } else {
    safe_delete(query);
  }
  return *this;
}

//Add a full sub-select to the query.
Builder &Builder::where_sub(const std::string &column, 
                            const std::string &oper,
                            closure_t callback,
                            const std::string &boolean) {
  // Once we have the query instance we can simply execute it so it can add all 
  // of the sub-select's conditions to itself, and then we can cache it off 
  // in the array of where clauses for the "main" parent query instance.
  db_query_array_t where;
  auto query = new_query();
  unique_move(Builder, query, where.query);

  callback(where.query.get());

  where.items = {
    {"type", "sub"}, {"column", column}, {"operator", oper}, 
    {"boolean", boolean},
  };

  add_binding(where.query->get_bindings(), "where");

  return *this;
}
